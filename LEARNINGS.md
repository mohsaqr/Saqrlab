# Saqrlab Project Learnings

### 2026-02-15
- [tna input formats]: `tna::tna()` accepts both a data frame of sequences (rows=sequences, cols=time points) and a square numeric matrix (transition frequencies). Column prefix can be "T" (as in `group_regulation`) not just "V".
- [group_regulation_long]: Structure is `Actor` (int), `Achiever` (chr), `Group` (num), `Course` (chr), `Time` (POSIXct), `Action` (chr). Has 27,533 rows, 9 unique actions (adapt, cohesion, consensus, coregulate, discuss, emotion, monitor, plan, synthesis).
- [group_regulation]: Wide format with T1-T26 columns (not V1-V26). 2000 rows. NAs are trailing (variable-length sequences).
- [tna model structure]: `tna` object is a list with `weights` (transition matrix), `inits` (initial probs), `labels` (state names), `data` (encoded sequences). `attr(model, "type")` is "relative" for probability weights.
- [transition counting]: To build a frequency matrix from sequences, count consecutive pairs (action[t], action[t+1]) within each sequence. For long data, split by ID and order by time first. For wide data, iterate across columns per row. Use `table()` with factors for vectorized counting.
- [frequencies.R]: File contains two functions: `frequencies()` builds a transition frequency matrix (state x state), `convert_sequence_format()` converts to frequency counts, onehot, edgelist, or follows format. Both accept wide and long input.
- [dplyr programmatic columns]: Use `dplyr::across(dplyr::all_of(col_names))` inside `group_by()`, `count()`, `distinct()` for programmatic column selection. Works with character vectors of column names. Avoids `!!sym()` / rlang dependency.
- [pivot_longer default]: `tidyr::pivot_longer()` creates a "name" column by default when `names_to` is not specified. This column is harmless if not used in downstream operations.
- [R CMD check]: Package has pre-existing warning about `\usage` entries in some man pages (not from new code). Hidden files (.claude, .github) and non-portable file paths in docs/ cache trigger NOTEs.
- [determinant]: `determinant()` is from `base`, not `stats`. Cannot use `@importFrom stats determinant` — just call it directly.
- [glasso]: `glasso::glasso()` returns list with `w` (estimated covariance), `wi` (estimated precision/inverse covariance). Warm starts use `start = "warm"` with `w.init` and `wi.init`. Cold start is default.
- [EBICglasso validation]: Our native EBIC + glasso implementation matches `qgraph::EBICglasso` exactly on test data (same partial correlations, same edges, same sparsity).
- [compositional frequency data]: Per-sequence action frequencies are compositional (rows sum to ~constant sequence length). This causes all partial correlations to be strongly negative. Expected behavior, not a bug.
- [glasso vs glassoFast]: Both have zero deps and use Fortran. `glassoFast` is ~2x faster but NOT available as a WebR (WASM) binary. `glasso` IS on the WebR repo. `glassoFast` also lacks `penalize.diagonal` param (always penalizes diagonal; workaround: pass rho as a matrix with zero diagonal). Chose `glasso` for WebR compatibility.
- [engagement stslist]: `tna::engagement` is an stslist object. Converting to frequency via `convert_sequence_format(as.data.frame(engagement), format = "frequency")` produces a `%` column (void/padding marker). Non-syntactic column names like `%` need auto-cleaning.
- [cograph::splot]: Preferred over `tplot()` for richer rendering. Supports `pie_values`/`pie_colors` for predictability pies, `donut_values`/`donut_color` for donuts, `node_fill` for node colors, `edge_labels = TRUE` for edge weights, `title` param directly (unlike tplot). Use `do.call(cograph::splot, dots)` to pass args programmatically. Default layout is `"oval"`.
- [cograph::tplot]: Thin qgraph-compatible wrapper around splot. Uses `pie`/`pieColor` (qgraph names). Does NOT accept `main` — use `title` param or `title()` after call.
- [build_network]: Renamed from `pcor_network()` to `build_network()` with `method` parameter. Supports `"glasso"` (aliases: `"ebicglasso"`, `"regularized"`), `"pcor"` (alias: `"partial"`), `"cor"` (alias: `"correlation"`). S3 class is `"psych_network"`. Main result field is `$network_matrix` (was `$pcor_matrix`). Auto-cleans non-syntactic column names, all-NA columns, NA rows, and zero-variance columns. Uses `glasso` package (WebR-compatible) for the glasso method.
- [build_network multilevel]: `level` parameter (`"between"`, `"within"`, `"both"`) decomposes data before estimation. Between = aggregate to person means; Within = person-mean center each variable (drops persons with <2 obs). `level = "both"` returns `psych_network_ml` S3 class. `id_col` is required when `level` is set. Must be data frame input (matrix not supported). The `id_vals` alignment with cleaned rows uses a `row_mask` boolean vector.
- [aggregate with formula]: `aggregate(. ~ .id, data = df, FUN = mean)` works well for between-person means. Returns `.id` column first, then all numeric columns. Must exclude `.id` from result matrix.
- [ave for centering]: `ave(x, group, FUN = mean)` returns group means expanded to original length — subtract from x to person-mean center. Works with integer or character grouping variables.
- [predictability]: Node predictability (R²) computed as `1 - 1/Omega_jj` for glasso/pcor (from precision matrix). For cor method, uses multiple R² from correlation matrix subsets (`crossprod(r, solve(R_nn, r))`). Follows Haslbeck & Waldorp (2018). Validated against mgm: r=0.999, mean |diff|=0.008. Zero dependencies added. Shown on plots via `pie_values` in splot, not printed by default.
- [plot styling]: Use `cograph::splot()` with `pie_values` for predictability, `node_fill` for pastel colors, `edge_labels = TRUE`, `theme = "colorblind"`, `node_size = 8`. Hand-picked palette of 15 distinct pastels cycles via `rep_len()`. For multilevel, use `par(mfrow = c(1, 2))` with `on.exit()` to restore.
- [group_regulation_long nesting]: Each Actor appears in exactly 1 Group (2000 actors, 200 groups, 10 actors/group). For multilevel decomposition, use Group as grouping variable (`id_col = c("Group", "Actor")` — first element is the grouping variable).

### 2026-02-16
- [Bayesian transition networks]: Not viable without an informative prior network. Uniform Dirichlet prior just does Laplace smoothing, making all transitions non-zero → bootstrap flags everything as significant. Only useful when researcher has a theoretical/prior transition matrix to update with data. `markovchain::markovchainFit(method = "map")` supports Bayesian estimation but only with uniform priors.
- [markovchain package]: Installed. `markovchainFit()` supports `method = "mle"`, `"laplace"` (add-1 smoothing), `"map"` (Bayesian). MAP returns `$estimate`, `$expectedValue`, `$standardError`, `$confidenceInterval`, `$logLikelihood`. Only supports uniform priors — no informative prior input.
- [existing comparison functions]: All TNA-specific. `compare_networks()` compares two TNA models (correlation, RMSE, edge weights). `compare_network_estimation()` compares TNA model types (tna/atna/ctna/ftna) via sampling stability. `compare_edge_recovery()` does binary edge TP/FP/FN. `cross_validate_tna()` cross-validates TNA model types. None work with `psych_network` objects from `build_network()`.
