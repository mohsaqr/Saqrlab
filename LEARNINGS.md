# Saqrlab Project Learnings

### 2026-02-15
- [tna input formats]: `tna::tna()` accepts both a data frame of sequences (rows=sequences, cols=time points) and a square numeric matrix (transition frequencies). Column prefix can be "T" (as in `group_regulation`) not just "V".
- [group_regulation_long]: Structure is `Actor` (int), `Achiever` (chr), `Group` (num), `Course` (chr), `Time` (POSIXct), `Action` (chr). Has 27,533 rows, 9 unique actions (adapt, cohesion, consensus, coregulate, discuss, emotion, monitor, plan, synthesis).
- [group_regulation]: Wide format with T1-T26 columns (not V1-V26). 2000 rows. NAs are trailing (variable-length sequences).
- [tna model structure]: `tna` object is a list with `weights` (transition matrix), `inits` (initial probs), `labels` (state names), `data` (encoded sequences). `attr(model, "type")` is "relative" for probability weights.
- [transition counting]: To build a frequency matrix from sequences, count consecutive pairs (action[t], action[t+1]) within each sequence. For long data, split by ID and order by time first. For wide data, iterate across columns per row. Use `table()` with factors for vectorized counting.
- [frequencies.R]: File contains two functions: `frequencies()` builds a transition frequency matrix (state x state), `convert_sequence_format()` converts to frequency counts, onehot, edgelist, or follows format. Both accept wide and long input.
- [dplyr programmatic columns]: Use `dplyr::across(dplyr::all_of(col_names))` inside `group_by()`, `count()`, `distinct()` for programmatic column selection. Works with character vectors of column names. Avoids `!!sym()` / rlang dependency.
- [pivot_longer default]: `tidyr::pivot_longer()` creates a "name" column by default when `names_to` is not specified. This column is harmless if not used in downstream operations.
- [R CMD check]: Package has pre-existing warning about `\usage` entries in some man pages (not from new code). Hidden files (.claude, .github) and non-portable file paths in docs/ cache trigger NOTEs.
- [determinant]: `determinant()` is from `base`, not `stats`. Cannot use `@importFrom stats determinant` — just call it directly.
- [glasso]: `glasso::glasso()` returns list with `w` (estimated covariance), `wi` (estimated precision/inverse covariance). Warm starts use `start = "warm"` with `w.init` and `wi.init`. Cold start is default.
- [EBICglasso validation]: Our native EBIC + glasso implementation matches `qgraph::EBICglasso` exactly on test data (same partial correlations, same edges, same sparsity).
- [compositional frequency data]: Per-sequence action frequencies are compositional (rows sum to ~constant sequence length). This causes all partial correlations to be strongly negative. Expected behavior, not a bug.
- [glasso vs glassoFast]: Both have zero deps and use Fortran. `glassoFast` is ~2x faster but NOT available as a WebR (WASM) binary. `glasso` IS on the WebR repo. `glassoFast` also lacks `penalize.diagonal` param (always penalizes diagonal; workaround: pass rho as a matrix with zero diagonal). Chose `glasso` for WebR compatibility.
- [engagement stslist]: `tna::engagement` is an stslist object. Converting to frequency via `convert_sequence_format(as.data.frame(engagement), format = "frequency")` produces a `%` column (void/padding marker). Non-syntactic column names like `%` need auto-cleaning.
- [cograph::splot]: Preferred over `tplot()` for richer rendering. Supports `pie_values`/`pie_colors` for predictability pies, `donut_values`/`donut_color` for donuts, `node_fill` for node colors, `edge_labels = TRUE` for edge weights, `title` param directly (unlike tplot). Use `do.call(cograph::splot, dots)` to pass args programmatically. Default layout is `"oval"`.
- [cograph::tplot]: Thin qgraph-compatible wrapper around splot. Uses `pie`/`pieColor` (qgraph names). Does NOT accept `main` — use `title` param or `title()` after call.
- [build_network]: Renamed from `pcor_network()` to `build_network()` with `method` parameter. Supports `"glasso"` (aliases: `"ebicglasso"`, `"regularized"`), `"pcor"` (alias: `"partial"`), `"cor"` (alias: `"correlation"`). S3 class is `"psych_network"`. Main result field is `$network_matrix` (was `$pcor_matrix`). Auto-cleans non-syntactic column names, all-NA columns, NA rows, and zero-variance columns. Uses `glasso` package (WebR-compatible) for the glasso method.
- [build_network multilevel]: `level` parameter (`"between"`, `"within"`, `"both"`) decomposes data before estimation. Between = aggregate to person means; Within = person-mean center each variable (drops persons with <2 obs). `level = "both"` returns `psych_network_ml` S3 class. `id_col` is required when `level` is set. Must be data frame input (matrix not supported). The `id_vals` alignment with cleaned rows uses a `row_mask` boolean vector.
- [aggregate with formula]: `aggregate(. ~ .id, data = df, FUN = mean)` works well for between-person means. Returns `.id` column first, then all numeric columns. Must exclude `.id` from result matrix.
- [ave for centering]: `ave(x, group, FUN = mean)` returns group means expanded to original length — subtract from x to person-mean center. Works with integer or character grouping variables.
- [predictability]: Node predictability (R²) computed as `1 - 1/Omega_jj` for glasso/pcor (from precision matrix). For cor method, uses multiple R² from correlation matrix subsets (`crossprod(r, solve(R_nn, r))`). Follows Haslbeck & Waldorp (2018). Validated against mgm: r=0.999, mean |diff|=0.008. Zero dependencies added. Shown on plots via `pie_values` in splot, not printed by default.
- [plot styling]: Use `cograph::splot()` with `pie_values` for predictability, `node_fill` for pastel colors, `edge_labels = TRUE`, `theme = "colorblind"`, `node_size = 8`. Hand-picked palette of 15 distinct pastels cycles via `rep_len()`. For multilevel, use `par(mfrow = c(1, 2))` with `on.exit()` to restore.
- [group_regulation_long nesting]: Each Actor appears in exactly 1 Group (2000 actors, 200 groups, 10 actors/group). For multilevel decomposition, use Group as grouping variable (`id_col = c("Group", "Actor")` — first element is the grouping variable).

### 2026-02-16
- [Bayesian transition networks]: Not viable without an informative prior network. Uniform Dirichlet prior just does Laplace smoothing, making all transitions non-zero → bootstrap flags everything as significant. Only useful when researcher has a theoretical/prior transition matrix to update with data. `markovchain::markovchainFit(method = "map")` supports Bayesian estimation but only with uniform priors.
- [markovchain package]: Installed. `markovchainFit()` supports `method = "mle"`, `"laplace"` (add-1 smoothing), `"map"` (Bayesian). MAP returns `$estimate`, `$expectedValue`, `$standardError`, `$confidenceInterval`, `$logLikelihood`. Only supports uniform priors — no informative prior input.
- [existing comparison functions]: All TNA-specific. `compare_networks()` compares two TNA models (correlation, RMSE, edge weights). `compare_network_estimation()` compares TNA model types (tna/atna/ctna/ftna) via sampling stability. `compare_edge_recovery()` does binary edge TP/FP/FN. `cross_validate_tna()` cross-validates TNA model types. None work with `psych_network` objects from `build_network()`.
- [estimate_network]: Universal estimation engine. `estimate_network(data, method, params, scaling, threshold, level, id_col)` → `saqr_network` S3 class. Supports 6 built-in methods: relative, frequency, co_occurrence (transition); cor, pcor, glasso (association). `params` list is the composability key — stores method-specific args for replay by bootstrap/grid search. `build_network()` now delegates to `estimate_network()` internally and converts output to `psych_network` for backward compat via `.saqr_to_psych_network()`.
- [estimator registry]: Global registry in `.estimator_registry` environment. `register_estimator(name, fn, description, directed)` / `get_estimator(name)` / `list_estimators()` / `remove_estimator(name)`. Built-ins registered in `.onLoad()` via `.register_builtin_estimators()`. Custom estimators can be added by users.
- [tabulate byrow]: When using `pair_idx = (from_int - 1) * n_states + to_int` with `tabulate()`, the resulting flat vector is in row-major order. R's `matrix()` fills column-major by default, so `byrow = TRUE` is required to get correct mat[from, to] indexing. Without it, from/to get silently swapped.
- [data.table globalVariables]: data.table NSE symbols `.SD`, `:=`, `.grp_key`, `.` need to be declared in `utils::globalVariables()` to avoid R CMD check NOTEs.
- [count_transitions NA handling]: When counting transitions, NAs must NOT be stripped before creating pairs. Instead, create consecutive pairs first (from = actions[-n], to = actions[-1]), then filter out pairs where either side is NA. Stripping NAs first creates false transitions by bridging gaps (e.g. A, NA, B → would falsely create A→B).
- [frequencies vectorized]: `frequencies()` now delegates to `.count_transitions()` which uses vectorized base R (matrix slicing + tabulate) for wide format and data.table for long format. Both are significantly faster than the old per-row `lapply` approach.
- [bootstrap_network]: Universal bootstrap for any estimator in `estimate_network()`. Two paths: transition methods use fast pre-computed per-sequence counts (single `tabulate` + `colSums` per iteration); association methods call the full estimator per iteration. Returns `saqr_bootstrap` S3 class with CIs, p-values, mean/SD, significant edges, pruned network. ~2.8x faster than `tna::bootstrap()` on 2000 sequences / 500 iterations due to `colSums` on 2D matrix (C-level) vs `apply` on 3D array (R-level).
- [bootstrap precomputation]: Per-sequence count matrices are built as n_seq x (n_states^2) 2D matrices using combined flat index `(row - 1) * nbins + pair_idx` with single `tabulate()`. Each bootstrap iteration only needs `colSums(trans_2d[sampled_rows, ])` + lightweight post-processing (row-normalize for relative).
- [bootstrap p-values]: Stability inference counts how many bootstrap replicates fall outside `[orig * cr_low, orig * cr_high]` multiplicative consistency range. Threshold inference counts how many replicates have absolute value below a fixed threshold. Both use vectorized `sweep()` on the full boot_matrices to avoid R-level loops.
- [bootstrap summary]: Long-format data frame built via `data.table::data.table()` for speed. Directed networks filter `weight != 0 & from != to`; undirected filter `weight != 0 & from < to` (upper triangle only).
- [bootstrap refactor]: Dropped long-format precompute helpers (bootstrap now requires wide format, errors with message to use `convert_sequence_format()`). Merged transition+co-occurrence wide precompute into single `.precompute_per_sequence_wide()`. Inlined `.postprocess_transition()` into vapply loop — builds matrix without dimnames since it's flattened immediately. Extracted `.select_state_cols()` shared helper into estimators.R. File went from 787 → 598 lines (~24% reduction). All 566 tests pass.
- [build_network consolidation]: `build_network()` is now the single entry point for all 6 estimation methods (was split between `build_network()` for association and `estimate_network()` for all). Returns `netobject` class (was `psych_network`/`saqr_network`). `estimate_network()` is now a deprecated wrapper that calls `build_network()`. `method` parameter is required (no default). Shared helpers (`.resolve_method_alias()`, `.apply_scaling()`, `.extract_edges_from_matrix()`, `.decompose_multilevel()`) live in estimate_network.R. S3 methods (print, plot, predictability) live in build_network.R.
- [netobject class]: Unified S3 class replacing `psych_network` and `saqr_network`. Fields: `$matrix`, `$nodes`, `$directed`, `$method`, `$params`, `$scaling`, `$threshold`, `$n_nodes`, `$n_edges`, `$edges`, `$level`, plus method-specific extras. Multilevel returns `netobject_ml` with `$between` and `$within` sub-objects.
- [method aliases]: `.resolve_method_alias()` maps: `tna`→`relative`, `ftna`→`frequency`, `cna`→`co_occurrence`, `corr`→`cor`, `transition`→`relative`, `counts`→`frequency`, `ebicglasso`/`regularized`→`glasso`, `partial`→`pcor`, `correlation`→`cor`.
- [testthat edition 3 deprecation]: `.Deprecated()` emits a warning, and testthat edition 3 (set in DESCRIPTION `Config/testthat/edition: 3`) treats warnings as test failures. All calls to deprecated functions in tests must be wrapped in `suppressWarnings()`.
- [plot predictability conditional]: `plot.netobject` only adds predictability pies for association methods (`method %in% c("glasso", "pcor", "cor")`), not transition methods. This avoids errors since transition methods don't produce precision matrices.
