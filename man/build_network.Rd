% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/build_network.R
\name{build_network}
\alias{build_network}
\title{Build a Network}
\usage{
build_network(
  data,
  method,
  params = list(),
  scaling = NULL,
  threshold = 0,
  level = NULL,
  id_col = NULL
)
}
\arguments{
\item{data}{Data frame (sequences or per-observation frequencies) or a
square symmetric matrix (correlation or covariance).}

\item{method}{Character. Required. Name of a registered estimator.
Built-in methods: \code{"relative"}, \code{"frequency"},
\code{"co_occurrence"}, \code{"cor"}, \code{"pcor"}, \code{"glasso"}.
Aliases: \code{"tna"} and \code{"transition"} map to \code{"relative"};
\code{"ftna"} and \code{"counts"} map to \code{"frequency"};
\code{"cna"} maps to \code{"co_occurrence"};
\code{"corr"} and \code{"correlation"} map to \code{"cor"};
\code{"partial"} maps to \code{"pcor"};
\code{"ebicglasso"} and \code{"regularized"} map to \code{"glasso"}.}

\item{params}{Named list. Method-specific parameters passed to the estimator
function (e.g. \code{list(gamma = 0.5)} for glasso, or
\code{list(format = "wide")} for transition methods). This is the key
composability feature: downstream functions like bootstrap or grid search
can store and replay the full params list without knowing method internals.}

\item{scaling}{Character vector or NULL. Post-estimation scaling to apply
(in order). Options: \code{"minmax"}, \code{"max"}, \code{"rank"},
\code{"normalize"}. Can combine: \code{c("rank", "minmax")}.
Default: \code{NULL} (no scaling).}

\item{threshold}{Numeric. Absolute values below this are set to zero in the
result matrix. Default: 0 (no thresholding).}

\item{level}{Character or NULL. Multilevel decomposition for association
methods. One of \code{NULL}, \code{"between"}, \code{"within"},
\code{"both"}. Requires \code{id_col}. Default: \code{NULL}.}

\item{id_col}{Character. Name of the ID column for multilevel decomposition.
Default: \code{NULL}.}
}
\value{
An object of class \code{"netobject"} containing:
\describe{
\item{matrix}{The estimated network weight matrix.}
\item{nodes}{Character vector of node names.}
\item{directed}{Logical. Whether the network is directed.}
\item{method}{The resolved method name.}
\item{params}{The params list used (for reproducibility).}
\item{scaling}{The scaling applied (or NULL).}
\item{threshold}{The threshold applied.}
\item{n_nodes}{Number of nodes.}
\item{n_edges}{Number of non-zero edges.}
\item{edges}{Data frame of non-zero edges (from, to, weight).}
\item{level}{Decomposition level used (or NULL).}
}
Method-specific extras (e.g. \code{precision_matrix}, \code{cor_matrix},
\code{frequency_matrix}, \code{lambda_selected}, etc.) are preserved
from the estimator output.

When \code{level = "both"}, returns an object of class
\code{"netobject_ml"} with \code{$between} and \code{$within}
sub-networks and a \code{$method} field.
}
\description{
Universal network estimation function that supports both transition
networks (relative, frequency, co-occurrence) and association networks
(correlation, partial correlation, graphical lasso). Uses the global
estimator registry, so custom estimators can also be used.
}
\details{
The function works as follows:
\enumerate{
\item Resolves method aliases to canonical names.
\item Retrieves the estimator function from the global registry.
\item For association methods with \code{level} specified, decomposes
the data (between-person means or within-person centering).
\item Calls the estimator: \code{do.call(fn, c(list(data = data), params))}.
\item Applies scaling and thresholding to the result matrix.
\item Extracts edges and constructs the \code{netobject}.
}
}
\examples{
\dontrun{
library(tna)

# Transition network (relative probabilities)
net <- build_network(group_regulation, method = "relative")
print(net)

# Aliases
net_tna <- build_network(group_regulation, method = "tna")
net_ftna <- build_network(group_regulation, method = "ftna")
net_cna <- build_network(group_regulation, method = "cna")

# Association network (glasso)
freq_data <- convert_sequence_format(group_regulation, format = "frequency")
net_glasso <- build_network(freq_data, method = "glasso",
                             params = list(gamma = 0.5, nlambda = 50))

# Partial correlation network
net_pcor <- build_network(freq_data, method = "pcor")

# Correlation network with alias
net_cor <- build_network(freq_data, method = "corr")

# With scaling
net_scaled <- build_network(group_regulation, method = "relative",
                             scaling = c("rank", "minmax"))

# Composable: replay config on new data
config <- net_glasso$params
net2 <- build_network(new_data, method = net_glasso$method,
                       params = config)
}

}
\seealso{
\code{\link{register_estimator}}, \code{\link{list_estimators}},
\code{\link{bootstrap_network}}
}
