% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/build_network.R
\name{build_network}
\alias{build_network}
\title{Build a Psychological Network}
\usage{
build_network(
  data,
  method = c("glasso", "ebicglasso", "regularized", "pcor", "partial", "cor",
    "correlation"),
  id_col = NULL,
  level = NULL,
  n = NULL,
  gamma = 0.5,
  nlambda = 100L,
  lambda.min.ratio = 0.01,
  penalize.diagonal = FALSE,
  threshold = 1e-04,
  cor_method = c("pearson", "spearman", "kendall"),
  input_type = c("auto", "cor", "cov")
)
}
\arguments{
\item{data}{A data frame of per-sequence action frequencies (e.g., output of
\code{\link{convert_sequence_format}} with \code{format = "frequency"}),
or a square symmetric correlation/covariance matrix.}

\item{method}{Character. Network estimation method. One of \code{"glasso"},
\code{"ebicglasso"}, \code{"regularized"} (all equivalent),
\code{"pcor"}, \code{"partial"} (equivalent),
\code{"cor"}, \code{"correlation"} (equivalent).
Default: \code{"glasso"}.}

\item{id_col}{Character vector. Name(s) of ID column(s) to exclude when
\code{data} is a data frame. If NULL, columns named \code{"rid"} and
non-numeric columns are automatically excluded. Default: NULL.}

\item{level}{Character or NULL. Decomposition level for multilevel networks
when data has repeated measures per person. One of:
\itemize{
\item \code{NULL} (default): no decomposition, current behavior.
\item \code{"between"}: aggregate to person means, estimate network
of trait-level associations.
\item \code{"within"}: person-mean center each variable, estimate
network of state-level (occasion-to-occasion) associations.
\item \code{"both"}: return both between and within networks in a
\code{psych_network_ml} object.
}
Requires \code{id_col} and a data frame input.}

\item{n}{Integer. Sample size. Required when \code{data} is a matrix.
Ignored when \code{data} is a data frame (n is taken from \code{nrow()}).
Default: NULL.}

\item{gamma}{Numeric. EBIC tuning parameter controlling sparsity preference
(only used when \code{method = "glasso"}). Higher values favour sparser
networks; 0 reduces to BIC. Default: 0.5.}

\item{nlambda}{Integer. Number of lambda values in the regularisation path
(only used when \code{method = "glasso"}). Default: 100.}

\item{lambda.min.ratio}{Numeric. Ratio of the smallest to the largest lambda
value (only used when \code{method = "glasso"}). Default: 0.01.}

\item{penalize.diagonal}{Logical. Whether to penalise the diagonal of the
precision matrix (only used when \code{method = "glasso"}).
Default: FALSE.}

\item{threshold}{Numeric. Absolute values in the result matrix below this
are set to zero. For \code{"glasso"} and \code{"pcor"} this applies to
partial correlations; for \code{"cor"} it applies to correlations.
Default: 1e-4.}

\item{cor_method}{Character. Correlation method when computing from a data
frame: \code{"pearson"}, \code{"spearman"}, or \code{"kendall"}.
Default: \code{"pearson"}.}

\item{input_type}{Character. How to interpret a matrix input:
\code{"auto"} (detect from diagonal), \code{"cor"}, or \code{"cov"}.
Default: \code{"auto"}.}
}
\value{
An object of class \code{"psych_network"} (or
\code{"psych_network_ml"} when \code{level = "both"}), a list containing:
\describe{
\item{network_matrix}{The estimated network weight matrix (partial
correlations for \code{"glasso"} and \code{"pcor"}; correlations for
\code{"cor"}). Diagonal is zero.}
\item{cor_matrix}{Correlation matrix used as input.}
\item{edges}{Data frame of non-zero edges (from, to, weight).}
\item{n}{Sample size.}
\item{p}{Number of variables.}
\item{method}{The resolved method name (\code{"glasso"}, \code{"pcor"},
or \code{"cor"}).}
\item{n_edges}{Number of non-zero edges.}
\item{level}{The decomposition level used (\code{NULL}, \code{"between"},
or \code{"within"}).}
}

Additional fields for \code{method = "glasso"}:
\describe{
\item{precision_matrix}{Estimated precision (inverse covariance) matrix.}
\item{lambda_selected}{The lambda value of the selected model.}
\item{ebic_selected}{The EBIC value of the selected model.}
\item{lambda_path}{Numeric vector of all lambda values evaluated.}
\item{ebic_path}{Numeric vector of EBIC values for each lambda.}
\item{gamma}{EBIC gamma used.}
}

Additional fields for \code{method = "pcor"}:
\describe{
\item{precision_matrix}{Precision (inverse correlation) matrix.}
}

When \code{level = "both"}, a \code{"psych_network_ml"} object is returned
containing:
\describe{
\item{between}{A \code{psych_network} object for the between-person level.}
\item{within}{A \code{psych_network} object for the within-person level.}
\item{method}{The resolved method name.}
}
}
\description{
Estimates a network from frequency data or a correlation/covariance matrix.
Supports three methods:
\itemize{
\item \code{"glasso"} (aliases: \code{"ebicglasso"}, \code{"regularized"}):
Sparse partial correlations via graphical lasso with EBIC model selection.
\item \code{"pcor"} (alias: \code{"partial"}):
Unregularised partial correlations (inverts the correlation matrix
directly; requires p < n).
\item \code{"cor"} (alias: \code{"correlation"}):
Pairwise correlation network.
}
}
\details{
When \code{data} is a data frame, the function automatically excludes
non-numeric columns, ID columns (\code{id_col} and \code{"rid"}), columns
with non-syntactic names (e.g., \code{"\%"}), zero-variance columns, and
columns that are entirely \code{NA}. Rows with any \code{NA} in the
remaining columns are dropped before computing correlations.

\strong{Method details:}
\describe{
\item{glasso}{Fits the graphical lasso across a log-spaced lambda path
using \code{glasso::glasso()} with warm starts, selects the model with
the lowest EBIC, and converts the precision matrix to partial
correlations.}
\item{pcor}{Directly inverts the correlation matrix to obtain the
precision matrix, then converts to partial correlations. Requires
\code{p < n} (more observations than variables).}
\item{cor}{Returns the pairwise correlation matrix as the network.
Values below \code{threshold} are zeroed out.}
}

\strong{Multilevel decomposition:}
When \code{level} is specified, the data is decomposed before estimation:
\describe{
\item{between}{Rows are aggregated to person means (using the first
element of \code{id_col} as the grouping variable), then the network
is estimated from the aggregated data.}
\item{within}{Each variable is person-mean centered (group-mean centering).
Persons with only one observation are dropped (no within-person
variance). The network is estimated from the pooled centered residuals.}
\item{both}{Both between and within networks are estimated and returned
in a \code{psych_network_ml} object.}
}
}
\examples{
\dontrun{
library(tna)

# From wide sequence data â€” regularised (default)
freq <- convert_sequence_format(group_regulation, format = "frequency")
net <- build_network(freq)
print(net)

# Unregularised partial correlations
net_pcor <- build_network(freq, method = "pcor")

# Correlation network
net_cor <- build_network(freq, method = "cor", threshold = 0.1)

# From a correlation matrix
S <- cor(freq[, -c(1, 2)])
net2 <- build_network(S, n = nrow(freq), method = "glasso")

# Multilevel: between-person network
freq_long <- convert_sequence_format(group_regulation_long,
  action = "Action", id_col = "Actor", format = "frequency")
net_between <- build_network(freq_long, id_col = "Actor",
  level = "between")

# Multilevel: both levels
net_ml <- build_network(freq_long, id_col = "Actor", level = "both")
print(net_ml)
}

}
\seealso{
\code{\link{convert_sequence_format}} for producing frequency data.
}
