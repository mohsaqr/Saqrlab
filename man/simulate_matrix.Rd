% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate_matrix.R
\name{simulate_matrix}
\alias{simulate_matrix}
\title{Simulate Network Matrix with Node Types}
\usage{
simulate_matrix(
  n_nodes = 20,
  n_types = 1,
  within_prob = 0.3,
  between_prob = 0.1,
  weighted = TRUE,
  weight_range = c(0.1, 1),
  directed = FALSE,
  allow_self_loops = FALSE,
  use_learning_states = TRUE,
  categories = "all",
  names = NULL,
  type_names = NULL,
  seed = NULL
)
}
\arguments{
\item{n_nodes}{Integer or integer vector. If single value, total number of nodes.
If vector, number of nodes per type. Default: 20.}

\item{n_types}{Integer. Number of node types/groups. Ignored if \code{n_nodes} is a
vector. Default: 1.}

\item{within_prob}{Numeric or numeric vector. Probability of edges within each
type. If single value, applies to all types. Default: 0.3.}

\item{between_prob}{Numeric or matrix. Probability of edges between different
types. If single value, applies to all between-type pairs. If matrix, should
be symmetric with dimensions n_types x n_types. Default: 0.1.}

\item{weighted}{Logical. If TRUE, generates weighted edges. If FALSE, binary
(0/1) matrix. Default: TRUE.}

\item{weight_range}{Numeric vector of length 2. Range for edge weights when
\code{weighted = TRUE}. Default: c(0.1, 1.0).}

\item{directed}{Logical. If TRUE, generates directed (asymmetric) matrix.
Default: FALSE.}

\item{allow_self_loops}{Logical. If TRUE, allows diagonal entries (self-loops).
Default: FALSE.}

\item{use_learning_states}{Logical. If TRUE, uses learning action verbs as
node names. Default: TRUE.}

\item{categories}{Character vector. Learning state categories to use when
\code{use_learning_states = TRUE}. Options: "metacognitive", "cognitive",
"behavioral", "social", "motivational", "affective", "group_regulation",
or "all". Default: "all".}

\item{names}{Character vector or NULL. Custom node names. Overrides
\code{use_learning_states} if provided. If NULL and \code{use_learning_states = FALSE},
uses names from \code{GLOBAL_NAMES}. Default: NULL.}

\item{type_names}{Character vector or NULL. Names for node types. If NULL,
uses "Type1", "Type2", etc. Default: NULL.}

\item{seed}{Integer or NULL. Random seed for reproducibility. Default: NULL.}
}
\value{
A list containing:
\describe{
\item{matrix}{Numeric matrix with row and column names set to node names.}
\item{node_types}{Named character vector mapping node names to their types.}
\item{type_names}{Character vector of type names.}
\item{n_nodes_per_type}{Integer vector of node counts per type.}
}
}
\description{
Generate a simulated adjacency or weight matrix for network analysis.
Supports single or multiple node types (communities/groups) with configurable
within-group and between-group connection probabilities.
}
\details{
The function implements a stochastic block model approach:
\itemize{
\item Nodes are assigned to types/groups
\item Edges within the same type occur with probability \code{within_prob}
\item Edges between different types occur with probability \code{between_prob}
\item Edge weights (if enabled) are uniformly distributed in \code{weight_range}
}

For undirected networks, the matrix is symmetric. For directed networks,
each potential edge is sampled independently.
}
\examples{
# Simple matrix with learning states (default)
result <- simulate_matrix(n_nodes = 10, seed = 42)
result$matrix

# Matrix with specific learning categories
result <- simulate_matrix(
  n_nodes = 8,
  categories = c("metacognitive", "cognitive"),
  seed = 42
)
colnames(result$matrix)

# Two-type network with learning states
result <- simulate_matrix(
  n_nodes = c(6, 4),
  type_names = c("Regulation", "Cognition"),
  within_prob = c(0.5, 0.6),
  between_prob = 0.2,
  categories = "group_regulation",
  seed = 42
)
result$matrix
table(result$node_types)

# Three communities with different densities
result <- simulate_matrix(
  n_nodes = c(5, 5, 5),
  type_names = c("Group_A", "Group_B", "Group_C"),
  within_prob = c(0.5, 0.4, 0.3),
  between_prob = 0.05,
  weighted = FALSE,
  seed = 123
)

# Using global names instead of learning states
result <- simulate_matrix(
  n_nodes = 10,
  use_learning_states = FALSE,
  seed = 42
)
colnames(result$matrix)  # Will show names like "Emma", "Liam", etc.

# Directed network
result <- simulate_matrix(
  n_nodes = 12,
  n_types = 2,
  directed = TRUE,
  seed = 42
)

}
\seealso{
\code{\link{simulate_edge_list}}, \code{\link{GLOBAL_NAMES}}
}
